# ğŸ›¡ï¸ Preventing Goroutine Leaks in Go

Goroutines in Go are **cheap** and **easy to spawn**, but theyâ€™re **not garbage collected** â€” meaning they can accumulate silently and cause memory leaks if not managed correctly ğŸš¨.

This guide outlines common goroutine leak patterns and how to **prevent** them using idiomatic **cancellation patterns** such as the `done` channel and the **or-channel pattern**.

---

## ğŸ’¡ Why Do Goroutines Leak?

Goroutines terminate when:

1. âœ… They complete their work.
    
2. âŒ They encounter an unrecoverable error.
    
3. âš ï¸ They're **told to stop** (cancellation).
    

Only the **third case** requires our intervention â€” and itâ€™s the most important due to goroutine **interdependence**. One goroutine may rely on others (like a graph ğŸŒ). The **parent goroutine**, which holds context, should be able to **cancel** its children.

---

## ğŸ”¥ Example: Goroutine Leak

```go
doWork := func(strings <-chan string) <-chan interface{} {
    completed := make(chan interface{})
    go func() {
        defer fmt.Println("doWork exited.")
        defer close(completed)
        for s := range strings {
            fmt.Println(s)
        }
    }()
    return completed
}

doWork(nil)
fmt.Println("Done.")
```

### âš ï¸ Whatâ€™s the Problem?

- We passed a **nil** channel.
    
- The goroutine blocks **forever** on `range strings`.
    
- In real apps, this leads to memory leaks over time.
    

---

## âœ… Solution: Use a `done` Channel

Use a **cancellation signal** from the parent goroutine:

```go
doWork := func(done <-chan interface{}, strings <-chan string) <-chan interface{} {
    terminated := make(chan interface{})
    go func() {
        defer fmt.Println("doWork exited.")
        defer close(terminated)
        for {
            select {
            case s := <-strings:
                fmt.Println(s)
            case <-done:
                return
            }
        }
    }()
    return terminated
}

done := make(chan interface{})
terminated := doWork(done, nil)

go func() {
    time.Sleep(1 * time.Second)
    fmt.Println("Canceling doWork goroutine...")
    close(done)
}()

<-terminated
fmt.Println("Done.")
```

ğŸ§  **Pattern**: Place `done` as the **first parameter**, use `for-select`, and watch for cancellation signals.

---

## ğŸ”„ Writing to a Channel (Blocked Writer Problem)

```go
newRandStream := func() <-chan int {
    randStream := make(chan int)
    go func() {
        defer fmt.Println("newRandStream closure exited.")
        defer close(randStream)
        for {
            randStream <- rand.Int()
        }
    }()
    return randStream
}
```

### âŒ Problem:

- Once the consumer stops reading after 3 values, the goroutine blocks **forever** on `randStream <-`.
    

---

## âœ… Fix With `done` Channel

```go
newRandStream := func(done <-chan interface{}) <-chan int {
    randStream := make(chan int)
    go func() {
        defer fmt.Println("newRandStream closure exited.")
        defer close(randStream)
        for {
            select {
            case randStream <- rand.Int():
            case <-done:
                return
            }
        }
    }()
    return randStream
}

done := make(chan interface{})
randStream := newRandStream(done)

fmt.Println("3 random ints:")
for i := 1; i <= 3; i++ {
    fmt.Printf("%d: %d\n", i, <-randStream)
}
close(done)
time.Sleep(1 * time.Second)
```

ğŸ§  **Takeaway**: Always give writers a way to stop via `done`.

---

## âœ… Convention Summary

> ğŸ§¾ **If a goroutine spawns another goroutine, it's responsible for ensuring it can cancel it.**

This ensures scalability and composability in large systems.

---

## ğŸ”€ The or-Channel Pattern

Sometimes, you want a **composite `done` channel** that listens to multiple cancellation signals.

### âœ… Example: Recursive `or` Channel

```go
var or func(channels ...<-chan interface{}) <-chan interface{}
or = func(channels ...<-chan interface{}) <-chan interface{} {
    switch len(channels) {
    case 0:
        return nil
    case 1:
        return channels[0]
    }

    orDone := make(chan interface{})
    go func() {
        defer close(orDone)
        switch len(channels) {
        case 2:
            select {
            case <-channels[0]:
            case <-channels[1]:
            }
        default:
            select {
            case <-channels[0]:
            case <-channels[1]:
            case <-channels[2]:
            case <-or(append(channels[3:], orDone)...):
            }
        }
    }()
    return orDone
}
```

### ğŸ§  Key Concepts:

- Recursive: builds a tree of `select`s.
    
- If **any** channel closes, the result channel (`orDone`) closes.
    
- Prevents goroutines from being orphaned when listening to **multiple cancellation signals**.
    

---

## âœ… Best Practices

âœ” Always pass `done` channels into goroutines.  
âœ” Use `select` inside `for` loops to monitor `done`.  
âœ” Use `defer` to clean up (`close` channels, log exit, etc.).  
âœ” Use the **or-channel** pattern to combine cancellation signals dynamically.  
âœ” Remember: **goroutines are not garbage collected** â€” they must be explicitly managed!

---

ğŸ§ª **Hint**: For testability and observability, always log when goroutines exit.

ğŸ§© **Pro Tip**: Use `context.Context` in production â€” it builds on these concepts with deadlines, timeouts, and cascading cancellation.