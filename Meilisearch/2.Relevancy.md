# 🚦 Meilisearch Relevancy and Built-in Ranking Rules

Relevancy in Meilisearch ensures search results are accurate and appropriate for a given query. This guide explores how Meilisearch achieves relevancy through its **built-in ranking rules**, their behavior, and how to configure them for optimal search results. 🛠️ All provided data is preserved, with added examples and tips to enhance understanding. Let’s dive in! 🏊

## 📌 What is Relevancy?

Relevancy measures the **accuracy and effectiveness** of search results in Meilisearch. If results consistently match the user's query intent, they are considered relevant. Meilisearch offers tools to fine-tune relevancy, with **ranking rules** being the most critical. These are divided into:

- **Built-in ranking rules**: Core rules provided by Meilisearch for sorting results.
- **Custom ranking rules**: User-defined rules for specific needs (not covered here).

This section focuses on **built-in ranking rules**, their behavior, and configuration.

**Example** 🎯: Searching for "batman dark knight" in a movie database should return films like *The Dark Knight* first, as they match all query terms, demonstrating high relevancy.

**Tip** 💡: Relevancy depends on your data and query patterns. Test ranking rule configurations to ensure results align with user expectations.

## 📚 Behavior of Ranking Rules

Each Meilisearch **index** has a list of ranking rules stored as an array in the **settings object**. These rules are applied using a **bucket sort algorithm** when a search query is made. Here’s how it works:

- **Order Matters**: Rules are applied sequentially. The first rule sorts all documents, and each subsequent rule acts as a tiebreaker for documents equal under the previous rule.
- **Customizability**: You can modify the rules array by adding, removing, or reordering rules via the **update settings endpoint** or **update ranking rules endpoint**.
- **Impact of Deletion**: Removing a rule (e.g., `typo`) means Meilisearch stops sorting based on that criterion, though matching documents are still returned.
- **Default Configuration**: Meilisearch’s default rules suit most use cases, but customization is available for specific needs.

**Example** 🎯: If you remove the `typo` rule, a query for "vogli" will still return documents with "volli," but they won’t be sorted by typo count.

**Tip** 💡: Always test changes to ranking rules with sample queries to ensure they improve relevancy for your use case.

**Warning** ⚠️: Reordering rules can significantly affect results. Place rules with the most impact (e.g., `words`) first to prioritize key criteria.

## 🌟 Built-in Ranking Rules

Meilisearch provides **six built-in ranking rules** in the following default order:

```json
[
  "words",
  "typo",
  "proximity",
  "attribute",
  "sort",
  "exactness"
]
```

These rules can be reordered or modified using the **update settings endpoint**. Below is a detailed breakdown of each rule, with examples and tips.

### 🎯 1. Words

**Description**: Sorts results by the **decreasing number of matched query terms**. Documents containing all query terms are ranked highest.

**Behavior**:
- Works **right to left** in the query string, meaning the order of terms affects results.
- Documents with more matching terms rank higher.

**Example** 🎯: For the query "batman dark knight":
- Documents with "batman," "dark," and "knight" (e.g., *The Dark Knight*) rank first.
- Documents with "batman" and "dark" (e.g., *Batman Begins*) rank second.
- Documents with only "batman" rank third.

**Tip** 💡: Ensure your query terms are specific to avoid overly broad results. For example, "dark knight" is better than just "knight" for movie searches.

**Artifact** 📦:
```go
package main

import (
    "fmt"
    "github.com/meilisearch/meilisearch-go"
)

func main() {
    client := meilisearch.NewClient(meilisearch.Config{
        Host:   "http://localhost:7700",
        APIKey: "masterKey",
    })
    index := client.Index("movies")
    // Assume index has documents with titles like "The Dark Knight", "Batman Begins"
    searchRes, _ := index.Search("batman dark knight", nil)
    for _, hit := range searchRes.Hits {
        fmt.Printf("Title: %v\n", hit)
    }
}
```

**Expected Output**:
```
Title: The Dark Knight (contains all terms: batman, dark, knight)
Title: Batman Begins (contains batman, dark)
Title: Batman Forever (contains batman)
```

### 🎯 2. Typo

**Description**: Sorts results by the **increasing number of typos** in matched query terms. Documents with fewer typos rank higher.

![[vogli3.png]]

**Example** 🎯: For the query "vogli":
- "vogli" (0 typos) ranks higher than "volli" (1 typo).

**Output**:
```
vogli: 0 typo
volli: 1 typo
```

**Tip** 💡: Keep the `typo` rule high in the order for forgiving searches, especially in e-commerce or user-generated content where typos are common.

**Warning** ⚠️: Removing the `typo` rule may reduce user satisfaction if queries often contain misspellings.

### 🎯 3. Proximity

**Description**: Sorts results by the **increasing distance** between matched query terms in the document. Documents where terms appear closer together and in the query’s order rank higher.

**Behavior**:
- Lowering precision can improve indexing performance but may reduce relevancy for multi-term queries.
  
  ![[new_road.png]]

**Example** 🎯: For the query "creature night":
- *Creature from the Black Lagoon* ranks higher than *Mississippi Grind* because the terms "creature" and "night" are closer in the former’s title.

**Tip** 💡: Adjust proximity precision in high-performance scenarios, but test thoroughly to avoid relevancy loss.

### 🎯 4. Attribute

**Description**: Sorts results based on the **attribute ranking order** defined in the index settings. Documents with query terms in more important attributes (e.g., title vs. overview) rank higher.

**Behavior**:
- Query terms at the **beginning** of an attribute are considered more relevant than those at the end.
  
  ![[belgium.png]]

**Example** 🎯: For the query "Belgium":
- *If It's Tuesday, This Must Be Belgium* ranks higher because "Belgium" is in the title, not just the overview.

**Tip** 💡: Define attribute importance in the index settings to prioritize fields like "title" over "description" for better relevancy.

### 🎯 5. Sort

**Description**: Sorts results based on **parameters specified at query time** (e.g., `sort=price:asc`). Only active when a valid `sort` parameter is provided.

**Behavior**:
- Higher position: Exhaustive sorting, prioritizing user-defined order over relevancy.
- Lower position: Relevant sorting, prioritizing relevancy over strict order.

**Example** 🎯: For the query "phone" with `sort=price:asc`:
- Results are sorted by ascending price, but if `sort` is low in the rules, relevancy (e.g., matching "phone") takes precedence.

**Tip** 💡: Place `sort` lower in the rules for searches where relevancy is more critical than strict sorting.

**Warning** ⚠️: Invalid or missing `sort` parameters cause this rule to be skipped, so ensure query parameters are correct.

### 🎯 6. Exactness

**Description**: Sorts results by the **similarity** of matched words to the query terms. Documents with exact matches rank higher.

**Example** 🎯: For the query "Knight":
- *Knight Moves* ranks higher than *Knights of Badassdom* because "Knight" is an exact match, while "Knights" has an extra "s".

**Output**:
```
Knight Moves: exact match
Knights of Badassdom: 1 letter difference
```

**Tip** 💡: Keep `exactness` in the rules to prioritize precise matches, especially for technical or specific searches.

## 🛠️ Configuring Ranking Rules

To modify ranking rules, use the **update settings endpoint** or **update ranking rules endpoint**. Example:

```json
{
  "rankingRules": [
    "words",
    "proximity",
    "typo",
    "attribute",
    "exactness",
    "sort"
  ]
}
```

**Explanation**:
- This reorders `proximity` before `typo`, prioritizing term closeness over typo count.
- Use a REST client or Meilisearch SDK to send this to the endpoint (e.g., `PUT /indexes/movies/settings/ranking-rules`).

**Tip** 💡: Test rule changes incrementally and use Meilisearch’s analytics to monitor how reordering affects user satisfaction.

## ✅ Summary

Meilisearch’s built-in ranking rules (`words`, `typo`, `proximity`, `attribute`, `sort`, `exactness`) provide a robust framework for ensuring relevant search results. By understanding and customizing these rules, you can tailor search behavior to your application’s needs. Always test configurations with real queries to balance relevancy and performance.

**Additional Example** 🎯: For an e-commerce index, you might prioritize `attribute` (to favor product names) and `sort` (for price sorting) higher than `typo` to cater to price-sensitive users.

**Warning** ⚠️: Avoid removing critical rules like `words` or `exactness` without a clear alternative, as this can degrade search quality.


# 🚦 Meilisearch Custom Ranking Rules and Sorting

Custom ranking rules in Meilisearch allow you to promote specific documents over others that are equally relevant, enhancing control over search result ordering. This guide details how to configure **custom ranking rules** and **sorting at search time**, with verbose examples and practical tips for optimal use in Meilisearch. All provided data is preserved, structured in Obsidian-friendly Markdown, and enriched with emojis for clarity. 🛠️ Let’s get started! 🏊



## 📌 Custom Ranking Rules Overview

Custom ranking rules in Meilisearch prioritize certain documents based on specific attributes, ensuring they appear higher in search results when relevancy is otherwise equal. Unlike **built-in ranking rules** (`words`, `typo`, `proximity`, `attribute`, `sort`, `exactness`), custom rules are user-defined and focus on sorting by attribute values in **ascending** (`asc`) or **descending** (`desc`) order.

**Key Points**:
- **Purpose**: Promote documents based on attributes like `release_date` or `movie_ranking`.
- **Format**: `attribute_name:asc` or `attribute_name:desc`.
- **Requirement**: The attribute must exist in all documents and have numeric or string values.
- **Configuration**: Add custom rules to the ranking rules array via the **update settings endpoint** or **update ranking rules endpoint**.

**Example** 🎯: In a movie database, you can prioritize older movies with `release_date:asc` or higher-ranked movies with `movie_ranking:desc`.

**Tip** 💡: Ensure all documents contain the attribute used in a custom rule to avoid undefined sorting behavior.

**Warning** ⚠️: Missing attributes in some documents can lead to unpredictable results. Always validate your dataset before applying custom rules.

## 🌟 Configuring Custom Ranking Rules

Custom ranking rules are added to the **ranking rules array** in the index settings. They are typically placed after built-in rules to act as tiebreakers, but their position can be adjusted based on priority.

### 🎯 Ascending and Descending Rules

- **Ascending (`asc`)**: Sorts by increasing attribute value (e.g., older dates first).
- **Descending (`desc`)**: Sorts by decreasing attribute value (e.g., higher numbers first).

**Syntax**:
- `attribute_name:asc` (e.g., `release_date:asc` for older movies first).
- `attribute_name:desc` (e.g., `movie_ranking:desc` for higher-ranked movies first).

**Example** 🎯: For a movie index with fields `release_date` (timestamp) and `movie_ranking` (integer):
- `release_date:asc`: Older movies (e.g., 1999) appear before newer ones (e.g., 2020).
- `movie_ranking:desc`: Movies with higher rankings appear first.

**Default Ranking Rules with Custom Additions**:
```json
[
  "words",
  "typo",
  "proximity",
  "attribute",
  "sort",
  "exactness",
  "release_date:asc",
  "movie_ranking:desc"
]
```

**Tip** 💡: Place custom rules lower in the array if you want built-in rules like `words` or `typo` to have higher priority.

### 🎯 Updating Ranking Rules

Use the **PUT /indexes/{index_uid}/settings/ranking-rules** endpoint to update rules.

**Example** 🎯: Update the `movies` index to include custom rules.

```go
package main

import (
    "fmt"
    "github.com/meilisearch/meilisearch-go"
)

func main() {
    client := meilisearch.NewClient(meilisearch.Config{
        Host:   "http://localhost:7700",
        APIKey: "masterKey",
    })
    rankingRules := []string{
        "words",
        "typo",
        "proximity",
        "attribute",
        "sort",
        "exactness",
        "release_date:asc",
        "movie_ranking:desc",
    }
    task, err := client.Index("movies").UpdateRankingRules(&rankingRules)
    if err != nil {
        fmt.Println("Error:", err)
        return
    }
    fmt.Printf("Task enqueued: %+v\n", task)
}
```

**Expected Response** (202 Accepted):
```json
{
  "taskUid": 1,
  "indexUid": "movies",
  "status": "enqueued",
  "type": "settingsUpdate",
  "enqueuedAt": "2021-08-11T09:25:53.000000Z"
}
```

**Tip** 💡: Use the `taskUid` to check the task status via the **GET /tasks/{taskUid}** endpoint to confirm the update.

**Warning** ⚠️: Ensure the attribute (e.g., `release_date`) exists in all documents to prevent inconsistent sorting.

### 🎯 Resetting Ranking Rules

Use the **DELETE /indexes/{index_uid}/settings/ranking-rules** endpoint to reset rules to their default:
```json
[
  "words",
  "typo",
  "proximity",
  "attribute",
  "sort",
  "exactness"
]
```

**Example** 🎯:
```go
package main

import (
    "fmt"
    "github.com/meilisearch/meilisearch-go"
)

func main() {
    client := meilisearch.NewClient(meilisearch.Config{
        Host:   "http://localhost:7700",
        APIKey: "masterKey",
    })
    task, err := client.Index("movies").ResetRankingRules()
    if err != nil {
        fmt.Println("Error:", err)
        return
    }
    fmt.Printf("Task enqueued: %+v\n", task)
}
```

**Expected Response** (202 Accepted):
```json
{
  "taskUid": 1,
  "indexUid": "movies",
  "status": "enqueued",
  "type": "settingsUpdate",
  "enqueuedAt": "2021-08-11T09:25:53.000000Z"
}
```

**Tip** 💡: Resetting is useful for reverting to a known state during testing or troubleshooting.

**Warning** ⚠️: Resetting removes all custom rules, so reapply any needed customizations afterward.

## 📚 Sorting at Search Time

Sorting at search time allows users to dynamically control result order using the **sort** search parameter, unlike custom ranking rules, which are always active once configured.

### 🎯 Key Differences

- **Sort Parameter**:
  - Defined at query time (e.g., `sort=price:asc`).
  - Ideal for user-driven sorting, like sorting products by price in a webshop.
- **Custom Ranking Rules**:
  - Always active after configuration.
  - Useful for promoting specific results, like discounted products.

**Example Use Case** 🎯:
- **Sort**: A webshop lets users sort products by `price:asc` or `price:desc`.
- **Custom Rule**: A webshop always shows discounted products first with `discount:desc`.

**Tip** 💡: Combine sort and custom rules for flexibility. Use custom rules for default behavior and sort for user preferences.

**Note**: Meilisearch does not natively support **promoting, pinning, or boosting** specific documents. Check Meilisearch blog articles for workarounds using React InstantSearch or document boosting.

### 🎯 Configuring Sorting

To enable sorting at search time:
1. **Choose Attributes**: Select fields for sorting (e.g., `author`, `price`).
2. **Update sortableAttributes**: Add these fields to the `sortableAttributes` index setting.
3. **Optional**: Adjust the `sort` ranking rule’s position for exhaustive or relevant sorting.

**sortableAttributes Example** 🎯: For a book index with fields `author` and `price`:
```go
package main

import (
    "fmt"
    "github.com/meilisearch/meilisearch-go"
)

func main() {
    client := meilisearch.NewClient(meilisearch.Config{
        Host:   "http://localhost:7700",
        APIKey: "masterKey",
    })
    sortableAttributes := []string{
        "author",
        "price",
    }
    task, err := client.Index("books").UpdateSortableAttributes(&sortableAttributes)
    if err != nil {
        fmt.Println("Error:", err)
        return
    }
    fmt.Printf("Task enqueued: %+v\n", task)
}
```

**Sorting Behavior**:
- **Strings**: Sorted lexicographically by byte value (e.g., `á` (225) sorts after `z` (122)). Uppercase/lowercase are treated the same but displayed as is.
- **Numbers vs. Strings**: Numbers take precedence over strings in mixed-type fields, which can cause unexpected results.

**Tip** 💡: Ensure sortable attributes have consistent data types across documents to avoid surprises.

**Warning** ⚠️: Only use numbers, strings, or arrays of numbers/strings for sorting to ensure predictable behavior.

### 🎯 Customizing Sort Rule Order

The `sort` rule’s position in the ranking rules affects its behavior:
- **High Position** (e.g., after `words`): Prioritizes user-defined sort order (exhaustive sorting).
- **Low Position** (default, fifth): Prioritizes relevancy over sort order (relevant sorting).

**Example** 🎯: Prioritize sorting for a price-focused webshop:
```go
package main

import (
    "fmt"
    "github.com/meilisearch/meilisearch-go"
)

func main() {
    client := meilisearch.NewClient(meilisearch.Config{
        Host:   "http://localhost:7700",
        APIKey: "masterKey",
    })
    rankingRules := []string{
        "words",
        "sort",
        "typo",
        "proximity",
        "attribute",
        "exactness",
    }
    task, err := client.Index("books").UpdateRankingRules(&rankingRules)
    if err != nil {
        fmt.Println("Error:", err)
        return
    }
    fmt.Printf("Task enqueued: %+v\n", task)
}
```

**Tip** 💡: Move `sort` higher for applications where user-defined order is critical, like e-commerce.

### 🎯 Sorting at Search Time

Use the `sort` parameter in search queries, specifying attributes from `sortableAttributes` in the format `attribute:asc` or `attribute:desc`.

**POST Route Example** 🎯:
```json
{
  "q": "science fiction",
  "sort": [
    "price:asc",
    "author:desc"
  ]
}
```

**GET Route Example** 🎯:
```
GET /indexes/books/search?q=science%20fiction&sort=price:asc,author:desc
```

**Behavior**:
- Attributes higher in the `sort` array take precedence.
- Example: If multiple books have the same `price`, Meilisearch sorts them by `author:desc`.

**Example** 🎯: Search for "science fiction" books, sorted by price (ascending):
```go
package main

import (
    "fmt"
    "github.com/meilisearch/meilisearch-go"
)

func main() {
    client := meilisearch.NewClient(meilisearch.Config{
        Host:   "http://localhost:7700",
        APIKey: "masterKey",
    })
    resp, err := client.Index("books").Search("science fiction", &meilisearch.SearchRequest{
        Sort: []string{
            "price:asc",
        },
    })
    if err != nil {
        fmt.Println("Error:", err)
        return
    }
    for _, hit := range resp.Hits {
        fmt.Printf("Book: %+v\n", hit)
    }
}
```

**Expected Output**:
```json
[
  {
    "id": 1,
    "title": "Solaris",
    "author": "Stanislaw Lem",
    "genres": ["science fiction"],
    "rating": {"critics": 95, "users": 87},
    "price": 5.00
  },
  {
    "id": 2,
    "title": "The Parable of the Sower",
    "author": "Octavia E. Butler",
    "genres": ["science fiction"],
    "rating": {"critics": 90, "users": 92},
    "price": 10.00
  }
]
```

**Example** 🎯: Group books by author for query "butler":
```go
package main

import (
    "fmt"
    "github.com/meilisearch/meilisearch-go"
)

func main() {
    client := meilisearch.NewClient(meilisearch.Config{
        Host:   "http://localhost:7700",
        APIKey: "masterKey",
    })
    resp, err := client.Index("books").Search("butler", &meilisearch.SearchRequest{
        Sort: []string{
            "author:desc",
        },
    })
    if err != nil {
        fmt.Println("Error:", err)
        return
    }
    for _, hit := range resp.Hits {
        fmt.Printf("Book: %+v\n", hit)
    }
}
```

**Expected Output**:
```json
[
  {
    "id": 2,
    "title": "The Parable of the Sower",
    "author": "Octavia E. Butler",
    "genres": ["science fiction"],
    "rating": {"critics": 90, "users": 92},
    "price": 10.00
  },
  {
    "id": 5,
    "title": "Wild Seed",
    "author": "Octavia E. Butler",
    "genres": ["fantasy"],
    "rating": {"critics": 84, "users": 80},
    "price": 5.00
  },
  {
    "id": 4,
    "title": "Gender Trouble",
    "author": "Judith Butler",
    "genres": ["feminism", "philosophy"],
    "rating": {"critics": 86, "users": 73},
    "price": 10.00
  }
]
```

### 🎯 Sorting by Nested Fields

Use **dot notation** to sort by nested fields (e.g., `rating.users`).

**Example** 🎯: Sort by user ratings:
```go
package main

import (
    "fmt"
    "github.com/meilisearch/meilisearch-go"
)

func main() {
    client := meilisearch.NewClient(meilisearch.Config{
        Host:   "http://localhost:7700",
        APIKey: "masterKey",
    })
    resp, err := client.Index("books").Search("science fiction", &meilisearch.SearchRequest{
        Sort: []string{
            "rating.users:asc",
        },
    })
    if err != nil {
        fmt.Println("Error:", err)
        return
    }
    for _, hit := range resp.Hits {
        fmt.Printf("Book: %+v\n", hit)
    }
}
```

**Tip** 💡: Ensure nested fields are added to `sortableAttributes` (e.g., `rating.users`) to enable sorting.

## ✅ Summary

- **Custom Ranking Rules**: Use `attribute:asc` or `attribute:desc` to promote documents based on specific attributes, applied consistently across searches.
- **Sorting at Search Time**: Use the `sort` parameter for user-driven sorting, requiring attributes in `sortableAttributes`.
- **Best Practices**: Validate attributes, test rule changes, and balance relevancy vs. sorting priority.
- **Resources**: Check Meilisearch’s [e-commerce demo](https://github.com/meilisearch/demos) and [CRM SaaS demo](https://github.com/meilisearch/demos) for practical implementations.

**Additional Example** 🎯: For a webshop, add a custom rule `discount:desc` to always show discounted products first, and allow users to sort by `price:asc` for budget-conscious shoppers.

**Warning** ⚠️: Inconsistent attribute types or missing attributes can disrupt sorting. Always verify your dataset’s consistency.

# 🚦 Meilisearch Ranking Score and Search Customization

The ranking score in Meilisearch quantifies the relevancy of search results, enabling fine-tuned control over document ordering. This guide explains the `_rankingScore`, `_rankingScoreDetails`, and related search parameters like `rankingScoreThreshold` and `attributesToSearchOn`. All provided data is preserved, formatted in Obsidian-friendly Markdown with emojis for readability, and enriched with verbose examples and tips. 🛠️ Let’s dive in! 🏊



## 📌 Understanding Ranking Score

The `_rankingScore` is a numeric value between **0.0** (least relevant) and **1.0** (most relevant) added to each document when the `showRankingScore` parameter is enabled. It reflects the document’s relevancy based on Meilisearch’s ranking rules, except for the `sort` rule, which does not influence the score.

**Key Points**:
- **Independence**: A document’s `_rankingScore` is fixed for a query and unaffected by other documents’ scores.
- **Influencing Settings**: The score is impacted by `searchableAttributes`, `rankingRules`, `stopWords`, `synonyms`, and `typoTolerance` (see table below).
- **Use Case**: Use `_rankingScore` to evaluate and fine-tune search relevancy.

**Table: Index Settings Influencing `_rankingScore`**:
| **Setting**            | **Influences If**                     | **Rationale**                                                                 |
|------------------------|---------------------------------------|------------------------------------------------------------------------------|
| `searchableAttributes` | `attribute` rule is used             | Scores depend on where query terms appear, based on attribute order.          |
| `rankingRules`         | Always                               | Scores are computed using subscores from each rule, weighted by their order.  |
| `stopWords`            | Always                               | Affects the `words` rule by ignoring stop words in queries.                   |
| `synonyms`             | Always                               | Affects the `words` rule by matching synonymous terms.                        |
| `typoTolerance`        | `typo` rule is used                  | Determines the maximum number of typos allowed for query matching.            |

**Example** 🎯: Searching for "dragon" in a movie index with `showRankingScore` enabled:
```go
package main

import (
    "fmt"
    "github.com/meilisearch/meilisearch-go"
)

func main() {
    client := meilisearch.NewClient(meilisearch.Config{
        Host:   "http://localhost:7700",
        APIKey: "masterKey",
    })
    resp, err := client.Index("movies").Search("dragon", &meilisearch.SearchRequest{
        ShowRankingScore: true,
    })
    if err != nil {
        fmt.Println("Error:", err)
        return
    }
    for _, hit := range resp.Hits {
        fmt.Printf("Hit: %+v\n", hit)
    }
}
```

**Expected Output**:
```json
{
  "hits": [
    {
      "id": 31072,
      "title": "Dragon",
      "overview": "In a desperate attempt to save her kingdom…",
      "_rankingScore": 0.92
    },
    {
      "id": 70057,
      "title": "Dragon",
      "overview": "A sinful martial arts expert wants…",
      "_rankingScore": 0.91
    }
  ]
}
```

**Tip** 💡: Use `_rankingScore` to debug relevancy issues by comparing scores across results.

**Warning** ⚠️: The `sort` rule does not affect `_rankingScore`, so sorting by a field (e.g., `price:asc`) may reorder results without changing their scores.

## 🌟 Ranking Score Details

The `showRankingScoreDetails` parameter adds a `_rankingScoreDetails` object to each document, breaking down the contribution of each active ranking rule. This is invaluable for understanding how Meilisearch computes relevancy.

**Parameter**:
- **Name**: `showRankingScoreDetails`
- **Values**: `true` or `false`
- **Default**: `false`

**Fields in `_rankingScoreDetails`**:
- **Common Fields**:
  - `order`: The position of the rule in the ranking rules array.
  - `score`: The subscore for the rule (0.0 to 1.0).
- **Rule-Specific Fields**:
  - **words**:
    - `matchingWords`: Number of query words matching in the document.
    - `maxMatchingWords`: Maximum possible matching words.
  - **typo**:
    - `typoCount`: Number of typos corrected for matching.
    - `maxTypoCount`: Maximum allowed typos.
  - **proximity**:
    - No additional fields beyond `order` and `score`.
  - **attribute**:
    - `attributeRankingOrderScore`: Score based on the attribute’s position in `searchableAttributes`.
    - `queryWordDistanceScore`: Score based on the distance between query words in attributes.
  - **exactness**:
    - `matchType`: `exactMatch` (all terms match in order with no extra words), `matchesStart` (all terms match in order), or `noExactMatch` (at least one term matches).
    - `matchingWords`: Number of exact matches (for `noExactMatch`).
    - `maxMatchingWords`: Maximum possible exact matches (for `noExactMatch`).
  - **field_name:direction** (custom sort rule, e.g., `name:asc`):
    - `value`: The field’s value used for sorting.
  - **_geoPoint(lat:lng):direction**:
    - `value`: The field’s value.
    - `distance`: The `_geoDistance` value.
  - **vectorSort(target_vector)**:
    - `value`: The vector used for sorting.
    - `similarity`: Similarity score (0.0 to 1.0) between the target and document vectors.

**Example** 🎯: Search for "dragon" with detailed ranking scores:
```go
package main

import (
    "fmt"
    "github.com/meilisearch/meilisearch-go"
)

func main() {
    client := meilisearch.NewClient(meilisearch.Config{
        Host:   "http://localhost:7700",
        APIKey: "masterKey",
    })
    resp, err := client.Index("movies").Search("dragon", &meilisearch.SearchRequest{
        ShowRankingScoreDetails: true,
    })
    if err != nil {
        fmt.Println("Error:", err)
        return
    }
    for _, hit := range resp.Hits {
        fmt.Printf("Hit: %+v\n", hit)
    }
}
```

**Expected Output**:
```json
{
  "hits": [
    {
      "id": 31072,
      "title": "Dragon",
      "overview": "In a desperate attempt to save her kingdom…",
      "_rankingScoreDetails": {
        "words": {
          "order": 0,
          "matchingWords": 4,
          "maxMatchingWords": 4,
          "score": 1.0
        },
        "typo": {
          "order": 2,
          "typoCount": 1,
          "maxTypoCount": 4,
          "score": 0.75
        },
        "name:asc": {
          "order": 1,
          "value": "Dragon"
        }
      }
    }
  ]
}
```

**Tip** 💡: Use `_rankingScoreDetails` to analyze which rules contribute most to relevancy and adjust `rankingRules` or `searchableAttributes` accordingly.

**Warning** ⚠️: The `sort` rule appears as individual fields (e.g., `name:asc`) in `_rankingScoreDetails`, not as a single `sort` entry.

## 📚 Ranking Score Threshold

The `rankingScoreThreshold` parameter filters out documents with `_rankingScore` below a specified value (0.0 to 1.0). Excluded documents are not counted in `estimatedTotalHits`, `totalHits`, or facet distributions.

**Parameter**:
- **Name**: `rankingScoreThreshold`
- **Values**: A number between 0.0 and 1.0
- **Default**: `null`

**Behavior**:
- For performance, Meilisearch may stop evaluating scores if the number of documents above the threshold exceeds the query’s `limit`.
- This can lead to overestimation of `estimatedTotalHits`, `totalHits`, and facet distributions.

**Example** 🎯: Filter results with `_rankingScore` > 0.2 for query "badman":
```go
package main

import (
    "fmt"
    "github.com/meilisearch/meilisearch-go"
)

func main() {
    client := meilisearch.NewClient(meilisearch.Config{
        Host:   "http://localhost:7700",
        APIKey: "masterKey",
    })
    resp, err := client.Index("movies").Search("badman", &meilisearch.SearchRequest{
        RankingScoreThreshold: 0.2,
    })
    if err != nil {
        fmt.Println("Error:", err)
        return
    }
    for _, hit := range resp.Hits {
        fmt.Printf("Hit: %+v\n", hit)
    }
}
```

**Tip** 💡: Use `rankingScoreThreshold` to ensure only highly relevant results are returned, improving user experience in precision-critical applications.

**Warning** ⚠️: Setting a high threshold may exclude relevant results, especially if your ranking rules are not well-tuned.

## 🌟 Customizing Searchable Attributes at Query Time

The `attributesToSearchOn` parameter limits search to specific attributes, overriding the default behavior of searching all `searchableAttributes`.

**Parameter**:
- **Name**: `attributesToSearchOn`
- **Values**: An array of attribute names or `["*"]`/`null` (search all `searchableAttributes`)
- **Default**: `["*"]`

**Behavior**:
- Attributes must be in the `searchableAttributes` list.
- The order of attributes in `attributesToSearchOn` does not affect relevancy, unlike `searchableAttributes`.

**Example** 🎯: Search for "adventure" only in the `overview` field:
```go
package main

import (
    "fmt"
    "github.com/meilisearch/meilisearch-go"
)

func main() {
    client := meilisearch.NewClient(meilisearch.Config{
        Host:   "http://localhost:7700",
        APIKey: "masterKey",
    })
    resp, err := client.Index("movies").Search("adventure", &meilisearch.SearchRequest{
        AttributesToSearchOn: []string{"overview"},
    })
    if err != nil {
        fmt.Println("Error:", err)
        return
    }
    for _, hit := range resp.Hits {
        fmt.Printf("Hit: %+v\n", hit)
    }
}
```

**Expected Behavior**:
- Only documents with "adventure" in the `overview` field are returned, even if `title` or `genre` contains "adventure" and is in `searchableAttributes`.

**Tip** 💡: Use `attributesToSearchOn` to focus searches on specific fields, like `description` for product searches, to improve precision.

**Warning** ⚠️: Ensure attributes in `attributesToSearchOn` are also in `searchableAttributes` to avoid errors.

## ✅ Summary

- **_rankingScore**: A 0.0–1.0 score reflecting document relevancy, influenced by `searchableAttributes`, `rankingRules`, `stopWords`, `synonyms`, and `typoTolerance`.
- **_rankingScoreDetails**: Provides a breakdown of each rule’s contribution, aiding in relevancy analysis.
- **rankingScoreThreshold**: Filters low-scoring documents, but high thresholds may exclude relevant results.
- **attributesToSearchOn**: Limits searches to specific fields, enhancing precision without affecting relevancy order.

**Additional Example** 🎯: Combine `showRankingScore`, `showRankingScoreDetails`, and `attributesToSearchOn` to analyze how searching only in `title` vs. `overview` affects scores for a query like "knight".

**Warning** ⚠️: Overly restrictive `rankingScoreThreshold` or `attributesToSearchOn` settings can reduce recall, so test thoroughly with representative queries.


# 🚦 Meilisearch Attribute Ranking Order and Searchable Fields

The order of attributes in Meilisearch’s `searchableAttributes` array significantly impacts search result relevancy, while also determining which fields are searchable. This guide explains how to configure `searchableAttributes`, manage attribute ranking order, and customize search behavior at query time. All provided data is preserved, formatted in Obsidian-friendly Markdown with emojis for clarity, and enhanced with verbose examples and tips. 🛠️ Let’s get started! 🏊



## 📌 Attribute Ranking Order Overview

In Meilisearch, the `searchableAttributes` array determines both **which fields are searchable** and their **relative importance** in calculating search result relevancy. Fields listed earlier in the array have a greater impact on relevancy, making them more influential in ranking results.

**Key Points**:
- **Default Behavior**: When `searchableAttributes` is set to `["*"]`, all fields are searchable with equal weight, based on their order in the first indexed document.
- **Manual Configuration**: Explicitly defining `searchableAttributes` allows you to prioritize fields (e.g., `title` over `overview`) and make some fields non-searchable (e.g., `id`).
- **Impact of Order**: Attributes higher in the list contribute more to a document’s `_rankingScore` under the `attribute` ranking rule.
- **Nested Fields**: Use dot notation (e.g., `review.critic`) to assign different weights to nested fields.

**Example** 🎯: For a movie index with fields `title`, `overview`, and `release_date`:
```json
[
  "title",
  "overview",
  "release_date"
]
```
- A query for “1984” prioritizes movies with “1984” in the `title` (e.g., *1984* by Michael Radford) over those with “1984” in `release_date`.

**Tip** 💡: Prioritize fields that users are likely to search (e.g., `title` in a movie database) to improve relevancy.

**Warning** ⚠️: The `attribute` rule’s position in `rankingRules` affects its impact. If it’s low in the list, attribute order may have minimal effect on results.

## 🌟 Searchable Fields

Fields in Meilisearch are either **searchable** (checked for query matches) or **non-searchable** (ignored during search but stored in the database). By default, all fields are searchable, but you can customize this to exclude fields like internal IDs or metadata.

**Key Points**:
- **Searchable Fields**: Used to assess document relevancy during searches.
- **Non-Searchable Fields**: Useful for data like URLs or sales numbers used for sorting or filtering, not searching.
- **Reversibility**: Non-searchable fields can be made searchable later by updating `searchableAttributes`.

**Example** 🎯: In a movie database, you might make `id` and `release_date` non-searchable to focus searches on `title`, `overview`, and `genres`.

**Tip** 💡: Use non-searchable fields for internal data to reduce noise in search results and improve performance.

## 📚 The `searchableAttributes` List

The `searchableAttributes` list serves two purposes:
1. **Designates Searchable Fields**: Specifies which fields Meilisearch searches for query terms.
2. **Dictates Ranking Order**: Determines the relative importance of fields for relevancy calculations.

### 🎯 Default Mode (Automatic)

- **Behavior**: All fields are searchable, ordered by their appearance in the first indexed document. New attributes in subsequent documents are appended to the list.
- **Indicator**: `searchableAttributes` set to `["*"]`.
- **Verification**: Use the **GET /indexes/{index_uid}/settings/searchable-attributes** endpoint.
- **Reset**: Set `searchableAttributes` to `[]` or use the **DELETE /indexes/{index_uid}/settings/searchable-attributes** endpoint to restore default behavior.

**Example** 🎯: If the first movie document is:
```json
{
  "id": 1,
  "title": "The Matrix",
  "overview": "A hacker discovers…",
  "genres": ["sci-fi"],
  "release_date": "1999"
}
```
- Default `searchableAttributes`: `["id", "title", "overview", "genres", "release_date"]`.

**Warning** ⚠️: The default order may not reflect desired relevancy priorities, so manual configuration is often necessary.

### 🎯 Manual Mode

- **Behavior**: Explicitly define `searchableAttributes` to control which fields are searchable and their ranking order. New attributes are not automatically added unless settings are reset.
- **Update**: Use the **PUT /indexes/{index_uid}/settings/searchable-attributes** endpoint.
- **Note**: A bug in Meilisearch may alter the displayed order of fields in JSON responses after manual updates (to be fixed in a future release).

**Example** 🎯: Make `id` and `release_date` non-searchable and prioritize `title`:
```go
package main

import (
    "fmt"
    "github.com/meilisearch/meilisearch-go"
)

func main() {
    client := meilisearch.NewClient(meilisearch.Config{
        Host:   "http://localhost:7700",
        APIKey: "masterKey",
    })
    searchableAttributes := []string{
        "title",
        "overview",
        "genres",
    }
    task, err := client.Index("movies").UpdateSearchableAttributes(&searchableAttributes)
    if err != nil {
        fmt.Println("Error:", err)
        return
    }
    fmt.Printf("Task enqueued: %+v\n", task)
}
```

**Expected Response** (202 Accepted):
```json
{
  "taskUid": 1,
  "indexUid": "movies",
  "status": "enqueued",
  "type": "settingsUpdate",
  "enqueuedAt": "2025-07-28T09:18:00.000000Z"
}
```

**Tip** 💡: Use the `taskUid` to check task status via **GET /tasks/{taskUid}** to confirm the update.

**Warning** ⚠️: After manual updates, new fields won’t be searchable until explicitly added, so monitor your dataset for changes.

### 🎯 Nested Fields

Nested fields inherit their parent’s weight unless specified with dot notation in `searchableAttributes`.

**Example** 🎯: Prioritize `review.critic` over `review.user`:
```json
[
  "title",
  "review.critic",
  "overview",
  "review.user"
]
```
- Matches in `review.critic` contribute more to relevancy than `review.user`.

**Tip** 💡: Use dot notation to fine-tune relevancy for nested fields, especially in complex datasets like product reviews.

## 🌟 Customizing Attributes at Search Time

The `attributesToSearchOn` parameter allows you to restrict a specific query to a subset of `searchableAttributes`, overriding the default behavior of searching all listed attributes.

**Parameter**:
- **Name**: `attributesToSearchOn`
- **Values**: An array of attribute names or `["*"]`/`null` (search all `searchableAttributes`)
- **Default**: `["*"]`

**Behavior**:
- Attributes must be in `searchableAttributes`.
- Order in `attributesToSearchOn` does not affect relevancy (unlike `searchableAttributes`).

**Example** 🎯: Search for “adventure” only in `overview`:
```go
package main

import (
    "fmt"
    "github.com/meilisearch/meilisearch-go"
)

func main() {
    client := meilisearch.NewClient(meilisearch.Config{
        Host:   "http://localhost:7700",
        APIKey: "masterKey",
    })
    resp, err := client.Index("movies").Search("adventure", &meilisearch.SearchRequest{
        AttributesToSearchOn: []string{"overview"},
    })
    if err != nil {
        fmt.Println("Error:", err)
        return
    }
    for _, hit := range resp.Hits {
        fmt.Printf("Hit: %+v\n", hit)
    }
}
```

**Expected Behavior**:
- Only documents with “adventure” in `overview` are returned, even if `title` or `genres` are in `searchableAttributes`.

**Tip** 💡: Use `attributesToSearchOn` to create targeted searches, like searching only product descriptions in an e-commerce app.

**Warning** ⚠️: Ensure attributes in `attributesToSearchOn` are in `searchableAttributes` to avoid query errors.

## ✅ Summary

- **searchableAttributes**: Controls which fields are searchable and their relevancy weight, with earlier attributes having more impact.
- **Default Mode**: All fields are searchable (`["*"]`), ordered by first document appearance.
- **Manual Mode**: Explicitly set searchable fields and their order, excluding non-relevant fields like `id`.
- **Nested Fields**: Use dot notation for granular control over nested field weights.
- **attributesToSearchOn**: Restrict specific queries to a subset of searchable fields without affecting relevancy order.

**Additional Example** 🎯: For a book index, set `searchableAttributes` to `["title", "author", "summary"]` and use `attributesToSearchOn: ["author"]` to search only author names for a query like “Tolkien”.

**Warning** ⚠️: The bug affecting JSON field order after manual `searchableAttributes` updates may confuse users; verify output in critical applications.


# 🚦 Meilisearch Typo Tolerance Settings

Typo tolerance in Meilisearch ensures users find relevant results despite spelling mistakes in their queries (e.g., "phnoe" matching "phone"). This guide details how to configure typo tolerance settings for an index, including enabling/disabling the feature, setting word size thresholds, and excluding specific words, attributes, or numbers. All provided data is preserved, formatted in Obsidian-friendly Markdown with emojis for clarity, and enriched with verbose examples and tips. 🛠️ Let’s dive in! 🏊



## 📌 Typo Tolerance Overview

Typo tolerance enhances the search experience by matching query terms with minor spelling errors to relevant documents. For example, a query for "phnoe" can match "phone." Meilisearch allows fine-grained control over typo tolerance settings per index, balancing flexibility and precision.

**Key Features**:
- **Enabled/Disabled**: Toggle typo tolerance on or off.
- **Word Size Thresholds**: Define minimum word lengths for allowing one or two typos.
- **Exclusions**: Disable typo tolerance for specific words, attributes, or numbers.
- **Special Cases**: First-character typos and word concatenations have unique handling.

**Example** 🎯: A query for "sevem" matches "seven" (one typo) because "seven" has five characters, meeting the default threshold for one typo.

**Tip** 💡: Keep typo tolerance enabled for most use cases to improve user experience, especially in e-commerce or casual search applications.

**Warning** ⚠️: In massive or multilingual datasets, typo tolerance may cause false positives. Test thoroughly before disabling.

## 🌟 Typo Tolerance Settings

Meilisearch provides several settings to customize typo tolerance, configurable via the **PATCH /indexes/{index_uid}/settings/typo-tolerance** endpoint.

### 🎯 Enabled

- **Description**: Enables or disables typo tolerance for the index.
- **Default**: `true`
- **Behavior**: When disabled, Meilisearch only matches exact query terms, ignoring words with typos (e.g., "phnoe" won’t match "phone").

**Example** 🎯: Disable typo tolerance for the `movies` index:
```go
package main

import (
    "fmt"
    "github.com/meilisearch/meilisearch-go"
)

func main() {
    client := meilisearch.NewClient(meilisearch.Config{
        Host:   "http://localhost:7700",
        APIKey: "masterKey",
    })
    task, err := client.Index("movies").UpdateTypoTolerance(&meilisearch.TypoTolerance{
        Enabled: false,
    })
    if err != nil {
        fmt.Println("Error:", err)
        return
    }
    fmt.Printf("Task enqueued: %+v\n", task)
}
```

**Expected Response** (202 Accepted):
```json
{
  "taskUid": 1,
  "indexUid": "movies",
  "status": "enqueued",
  "type": "settingsUpdate",
  "enqueuedAt": "2025-07-28T09:21:00.000000Z"
}
```

**Tip** 💡: Disable typo tolerance in multilingual datasets to avoid false positives, but test with sample queries to ensure relevancy isn’t compromised.

**Warning** ⚠️: Disabling typo tolerance may frustrate users who expect forgiving searches, especially for common misspellings.

### 🎯 minWordSizeForTypos

- **Description**: Sets the minimum word length for allowing one or two typos.
- **Default**:
  - `oneTypo`: 5 (words with 5+ characters allow 1 typo)
  - `twoTypos`: 9 (words with 9+ characters allow 2 typos)
- **Constraints**:
  - `0 ≤ oneTypo ≤ twoTypos ≤ 255`
  - Recommended: `oneTypo` between 2–8, `twoTypos` between 4–14
- **Behavior**: Words shorter than `oneTypo` require exact matches. Words between `oneTypo` and `twoTypos` allow one typo. Words at or above `twoTypos` allow two typos.

**Example** 🎯: Set `oneTypo` to 4 and `twoTypos` to 10:
```go
package main

import (
    "fmt"
    "github.com/meilisearch/meilisearch-go"
)

func main() {
    client := meilisearch.NewClient(meilisearch.Config{
        Host:   "http://localhost:7700",
        APIKey: "masterKey",
    })
    task, err := client.Index("movies").UpdateTypoTolerance(&meilisearch.TypoTolerance{
        MinWordSizeForTypos: meilisearch.MinWordSizeForTypos{
            OneTypo: 4,
            TwoTypos: 10,
        },
    })
    if err != nil {
        fmt.Println("Error:", err)
        return
    }
    fmt.Printf("Task enqueued: %+v\n", task)
}
```

**Expected Behavior**:
- Query "tow" won’t match "two" (3 characters < 4).
- Query "sevem" matches "seven" (5 characters ≥ 4, 1 typo).
- Query "beautifil" matches "beautiful" (9 characters < 10, 1 typo allowed).

**Tip** 💡: Lower `oneTypo` (e.g., 3) for datasets with short words, but beware of false positives.

**Warning** ⚠️: Setting `oneTypo` too low (e.g., 1) or `twoTypos` too high (e.g., 20) can lead to irrelevant matches or performance issues.

### 🎯 Special Typo Rules

- **First-Character Typo**: Counts as **two typos** because it significantly alters the word’s identity. For example, "phnoe" to "phone" requires a first-character change, so it’s only matched if `twoTypos` allows it (e.g., word length ≥ 9 by default).
- **Concatenation**: Meilisearch treats space-separated terms as a single typo if concatenated. For example, "any way" matches "anyway" as one typo.

**Example** 🎯: Query "any way" matches "anyway" in a document because concatenation is treated as one typo.

**Tip** 💡: Concatenation handling is useful for queries with flexible phrasing, but test with your dataset to ensure it doesn’t cause unwanted matches.

### 🎯 disableOnWords

- **Description**: Disables typo tolerance for specific query terms (case-insensitive).
- **Default**: Empty array (`[]`)
- **Behavior**: Queries for listed words require exact matches.

**Example** 🎯: Disable typo tolerance for "shrek":
```go
package main

import (
    "fmt"
    "github.com/meilisearch/meilisearch-go"
)

func main() {
    client := meilisearch.NewClient(meilisearch.Config{
        Host:   "http://localhost:7700",
        APIKey: "masterKey",
    })
    task, err := client.Index("movies").UpdateTypoTolerance(&meilisearch.TypoTolerance{
        DisableOnWords: []string{"shrek"},
    })
    if err != nil {
        fmt.Println("Error:", err)
        return
    }
    fmt.Printf("Task enqueued: %+v\n", task)
}
```

**Expected Behavior**:
- Query "shreak" won’t match "Shrek" because typo tolerance is disabled for "shrek".

**Tip** 💡: Use `disableOnWords` for brand names or specific terms where typos are undesirable (e.g., product codes).

**Warning** ⚠️: Overusing `disableOnWords` can reduce search forgiveness, so limit it to critical terms.

### 🎯 disableOnAttributes

- **Description**: Disables typo tolerance for specific attributes.
- **Default**: Empty array (`[]`)
- **Behavior**: Matches in the specified attributes require exact query terms.

**Example** 🎯: Disable typo tolerance for the `title` attribute:
```go
package main

import (
    "fmt"
    "github.com/meilisearch/meilisearch-go"
)

func main() {
    client := meilisearch.NewClient(meilisearch.Config{
        Host:   "http://localhost:7700",
        APIKey: "masterKey",
    })
    task, err := client.Index("movies").UpdateTypoTolerance(&meilisearch.TypoTolerance{
        DisableOnAttributes: []string{"title"},
    })
    if err != nil {
        fmt.Println("Error:", err)
        return
    }
    fmt.Printf("Task enqueued: %+v\n", task)
}
```

**Expected Behavior**:
- Query "beautifil" won’t match "beautiful" in the `title` field (e.g., *Beautiful Mind*), but may match in other attributes like `overview`.

**Tip** 💡: Use `disableOnAttributes` for fields where precision is critical, such as movie titles or SKUs.

**Warning** ⚠️: Disabling typo tolerance on key attributes may reduce recall, so balance with user expectations.

### 🎯 disableOnNumbers

- **Description**: Disables typo tolerance for numeric values across all attributes.
- **Default**: `false` (typo tolerance enabled for numbers)
- **Behavior**: When `true`, numeric queries (e.g., "2024") only match exact values, not similar numbers (e.g., "2025").

**Example** 🎯: Disable typo tolerance for numbers:
```go
package main

import (
    "fmt"
    "github.com/meilisearch/meilisearch-go"
)

func main() {
    client := meilisearch.NewClient(meilisearch.Config{
        Host:   "http://localhost:7700",
        APIKey: "masterKey",
    })
    task, err := client.Index("movies").UpdateTypoTolerance(&meilisearch.TypoTolerance{
        DisableOnNumbers: true,
    })
    if err != nil {
        fmt.Println("Error:", err)
        return
    }
    fmt.Printf("Task enqueued: %+v\n", task)
}
```

**Expected Behavior**:
- Query "2024" won’t match "2025" or "2004" in fields like `release_date`.

**Tip** 💡: Enable `disableOnNumbers` for datasets with precise numeric fields (e.g., years, prices) to avoid false positives and improve indexing performance.

**Warning** ⚠️: Disabling number typo tolerance may exclude relevant results in contexts where approximate matches are acceptable (e.g., price ranges).

## 📚 Updating Typo Tolerance Settings

Use the **PATCH /indexes/{index_uid}/settings/typo-tolerance** endpoint to update settings.

**Body Format**:
```json
{
  "enabled": <Boolean>,
  "minWordSizeForTypos": {
    "oneTypo": <Integer>,
    "twoTypos": <Integer>
  },
  "disableOnWords": [<String>, <String>, …],
  "disableOnAttributes": [<String>, <String>, …],
  "disableOnNumbers": <Boolean>
}
```

**Example** 🎯: Combine multiple settings for a `books` index:
```go
package main

import (
    "fmt"
    "github.com/meilisearch/meilisearch-go"
)

func main() {
    client := meilisearch.NewClient(meilisearch.Config{
        Host:   "http://localhost:7700",
        APIKey: "masterKey",
    })
    task, err := client.Index("books").UpdateTypoTolerance(&meilisearch.TypoTolerance{
        MinWordSizeForTypos: meilisearch.MinWordSizeForTypos{
            OneTypo: 4,
            TwoTypos: 10,
        },
        DisableOnAttributes: []string{"title"},
    })
    if err != nil {
        fmt.Println("Error:", err)
        return
    }
    fmt.Printf("Task enqueued: %+v\n", task)
}
```

**Expected Response** (202 Accepted):
```json
{
  "taskUid": 1,
  "indexUid": "books",
  "status": "enqueued",
  "type": "settingsUpdate",
  "enqueuedAt": "2025-07-28T09:21:00.000000Z"
}
```

**Tip** 💡: Use the `taskUid` to monitor task status via **GET /tasks/{taskUid}** to ensure settings are applied.

## 🌟 Resetting Typo Tolerance Settings

Use the **DELETE /indexes/{index_uid}/settings/typo-tolerance** endpoint to reset settings to defaults:
- `enabled`: `true`
- `minWordSizeForTypos`: `{ oneTypo: 5, twoTypos: 9 }`
- `disableOnWords`: `[]`
- `disableOnAttributes`: `[]`
- `disableOnNumbers`: `false`

**Example** 🎯:
```go
package main

import (
    "fmt"
    "github.com/meilisearch/meilisearch-go"
)

func main() {
    client := meilisearch.NewClient(meilisearch.Config{
        Host:   "http://localhost:7700",
        APIKey: "masterKey",
    })
    task, err := client.Index("books").ResetTypoTolerance()
    if err != nil {
        fmt.Println("Error:", err)
        return
    }
    fmt.Printf("Task enqueued: %+v\n", task)
}
```

**Expected Response** (202 Accepted):
```json
{
  "taskUid": 1,
  "indexUid": "books",
  "status": "enqueued",
  "type": "settingsUpdate",
  "enqueuedAt": "2025-07-28T09:21:00.000000Z"
}
```

**Tip** 💡: Reset settings during testing or when troubleshooting unexpected search behavior.

## ✅ Summary

- **Typo Tolerance**: Enhances search by matching misspelled queries, configurable per index.
- **Settings**:
  - `enabled`: Toggle typo tolerance (default: `true`).
  - `minWordSizeForTypos`: Set thresholds for one and two typos (default: 5 and 9).
  - `disableOnWords`: Exclude specific words from typo tolerance.
  - `disableOnAttributes`: Require exact matches for certain fields.
  - `disableOnNumbers`: Enforce exact numeric matches.
- **Special Cases**: First-character typos count as two; concatenations count as one.

**Additional Example** 🎯: For an e-commerce index, set `disableOnAttributes: ["sku"]` and `disableOnNumbers: true` to ensure precise matches for product codes and prices, while keeping `minWordSizeForTypos: { oneTypo: 3, twoTypos: 8 }` for forgiving product name searches.

**Warning** ⚠️: Overly restrictive settings (e.g., disabling typo tolerance broadly) may reduce recall, so test with real user queries to balance precision and flexibility.



# 🚦 Meilisearch Typo Tolerance Calculations

Typo tolerance in Meilisearch ensures users find relevant results despite spelling mistakes in their queries, such as typing "phnoe" instead of "phone." This guide explains how Meilisearch calculates typos using the prefix Levenshtein algorithm and how these calculations interact with the `typo` ranking rule. All provided data is preserved, formatted in Obsidian-friendly Markdown with emojis for clarity, and enhanced with verbose examples and tips. 🛠️ Let’s dive in! 🏊



## 📌 Understanding Typo Tolerance Calculations

Meilisearch uses the **prefix Levenshtein algorithm** to determine if a document’s words match a query term despite typos. The **Levenshtein distance** represents the minimum number of single-character edits (substitutions, insertions, or deletions) needed to transform one word into another. Typo tolerance calculations are applied **per word**, not across the entire query string, and are governed by configurable settings.

**Levenshtein Operations**:
- **Substitution**: Replace one character (e.g., `kitten` → `sitten`).
- **Insertion**: Add a character (e.g., `siting` → `sitting`).
- **Deletion**: Remove a character (e.g., `saturday` → `satuday`).

**Default Typo Rules**:
- **1–4 characters**: No typos allowed. Only exact matches or words starting with the query term are valid.
- **5–8 characters**: One typo allowed. Documents with words matching within one edit are retained.
- **9+ characters**: Up to two typos allowed.

**Special Cases**:
- **First-Character Typo**: Counts as **two typos** due to its significant impact on word identity.
- **Concatenation**: Treated as one typo (e.g., "any way" matches "anyway").

**Example** 🎯: For the query word "saturday" (7 characters):
- Matches: `saturday` (0 typos), `satuday` (1 typo, deletion).
- Non-Matches: `sutuday` (2 typos, first-character substitution + deletion), `caturday` (2 typos, first-character substitution).

**Tip** 💡: Adjust `minWordSizeForTypos` in typo tolerance settings to tailor these rules to your dataset’s word lengths.

**Warning** ⚠️: First-character typos are stricter, so ensure your dataset and queries align with user expectations for typo forgiveness.

## 🌟 Default Typo Tolerance Rules

Meilisearch’s default rules for typo tolerance are based on query word length:

| **Word Length** | **Typos Allowed** | **Behavior**                                                                 |
|-----------------|-------------------|------------------------------------------------------------------------------|
| 1–4 characters  | 0                 | Exact matches or words starting with the query term are valid.                |
| 5–8 characters  | 1                 | Documents with one typo (substitution, insertion, or deletion) are retained.  |
| 9+ characters   | 2                 | Documents with up to two typos are retained.                                  |

**Example** 🎯: Query "saturday" (7 characters, 1 typo allowed):
- **Matches**:
  - `saturday` (0 typos)
  - `satuday` (1 typo, deletion of "r")
- **Non-Matches**:
  - `sutuday` (2 typos: first-character substitution `s`→`u`, deletion of "r")
  - `caturday` (2 typos: first-character substitution `s`→`c`)

**Example** 🎯: Query "beautiful" (9 characters, 2 typos allowed):
- Matches: `beautiful` (0 typos), `beautifil` (1 typo, substitution `u`→`i`), `beautifull` (1 typo, insertion of "l").
- Non-Matches: `biutiful` (3 typos, including first-character substitution `b`→`i` counting as 2).

**Tip** 💡: For datasets with short words (e.g., product codes), lower the `oneTypo` threshold to allow typos on 3–4 character words.

**Warning** ⚠️: Allowing too many typos on short words can lead to false positives, reducing search precision.

## 📚 Impact on the Typo Ranking Rule

The `typo` ranking rule sorts search results by the **increasing number of typos** in matched query words, with documents having fewer typos ranked higher. While `typo tolerance` determines which documents are matched, the `typo` ranking rule controls their order.

**Key Interactions**:
- **Typo Tolerance**: Defines how lenient Meilisearch is when matching documents (e.g., allowing 1 or 2 typos).
- **Typo Ranking Rule**: Sorts matched documents by typo count (0 typos > 1 typo > 2 typos).
- **Disabling Typo Tolerance**: If `enabled: false` in typo tolerance settings, only exact matches are returned, effectively disabling the `typo` ranking rule since all matches have 0 typos.

**Example** 🎯: Search for "phnoe" in a movie index:
```go
package main

import (
    "fmt"
    "github.com/meilisearch/meilisearch-go"
)

func main() {
    client := meilisearch.NewClient(meilisearch.Config{
        Host:   "http://localhost:7700",
        APIKey: "masterKey",
    })
    resp, err := client.Index("movies").Search("phnoe", &meilisearch.SearchRequest{
        ShowRankingScoreDetails: true,
    })
    if err != nil {
        fmt.Println("Error:", err)
        return
    }
    for _, hit := range resp.Hits {
        fmt.Printf("Hit: %+v\n", hit)
    }
}
```

**Expected Output** (assuming default settings):
```json
{
  "hits": [
    {
      "id": 123,
      "title": "Phone Booth",
      "_rankingScoreDetails": {
        "typo": {
          "order": 1,
          "typoCount": 1,
          "maxTypoCount": 1,
          "score": 0.5
        },
        ...
      }
    },
    {
      "id": 456,
      "title": "The Phone",
      "_rankingScoreDetails": {
        "typo": {
          "order": 1,
          "typoCount": 2,
          "maxTypoCount": 2,
          "score": 0.25
        },
        ...
      }
    }
  ]
}
```

**Explanation**:
- "Phone Booth" (1 typo, `phnoe`→`phone`) ranks higher than "The Phone" (2 typos, first-character typo counts as 2).
- The `typo` rule sorts results by increasing typo count.

**Tip** 💡: Use `_rankingScoreDetails` to analyze how typo counts affect result ordering and adjust `minWordSizeForTypos` if needed.

**Warning** ⚠️: Disabling typo tolerance (`enabled: false`) eliminates the `typo` rule’s effect, potentially reducing result recall for misspelled queries.

## 🌟 Configuring Typo Tolerance for Calculations

Typo tolerance settings (covered in the previous document) directly influence calculations:
- **minWordSizeForTypos**: Adjusts the thresholds for allowing 1 or 2 typos.
- **disableOnWords**: Excludes specific words from typo tolerance, requiring exact matches.
- **disableOnAttributes**: Requires exact matches in specified fields.
- **disableOnNumbers**: Enforces exact numeric matches.

**Example** 🎯: Adjust `minWordSizeForTypos` to allow one typo for 3+ character words:
```go
package main

import (
    "fmt"
    "github.com/meilisearch/meilisearch-go"
)

func main() {
    client := meilisearch.NewClient(meilisearch.Config{
        Host:   "http://localhost:7700",
        APIKey: "masterKey",
    })
    task, err := client.Index("movies").UpdateTypoTolerance(&meilisearch.TypoTolerance{
        MinWordSizeForTypos: meilisearch.MinWordSizeForTypos{
            OneTypo: 3,
            TwoTypos: 8,
        },
    })
    if err != nil {
        fmt.Println("Error:", err)
        return
    }
    fmt.Printf("Task enqueued: %+v\n", task)
}
```

**Expected Behavior**:
- Query "tow" matches "two" (3 characters, 1 typo).
- Query "saturdy" matches "saturday" (7 characters, 1 typo).
- Query "beautifil" matches "beautiful" (9 characters, 2 typos allowed).

**Tip** 💡: Lower `oneTypo` for datasets with short, commonly misspelled words, but monitor for false positives.

## ✅ Summary

- **Typo Tolerance Calculations**: Uses the prefix Levenshtein algorithm to match words based on substitutions, insertions, or deletions.
- **Default Rules**: 0 typos for 1–4 characters, 1 typo for 5–8 characters, 2 typos for 9+ characters.
- **Special Cases**: First-character typos count as two; concatenations count as one.
- **Typo Ranking Rule**: Sorts results by increasing typo count, but is disabled if typo tolerance is off.
- **Configuration**: Adjust settings like `minWordSizeForTypos` to fine-tune matching behavior.

**Additional Example** 🎯: For an e-commerce index, set `minWordSizeForTypos: { oneTypo: 3, twoTypos: 8 }` and `disableOnWords: ["sku123"]` to allow typos on product names but require exact matches for specific SKUs.

**Warning** ⚠️: Disabling typo tolerance or setting strict thresholds may exclude relevant results, so test with real-world queries to ensure a balanced user experience.



# 🚦 Meilisearch Distinct Attribute

The **distinct attribute** in Meilisearch ensures that search results contain only one document per unique value of a specified field, preventing the return of multiple similar documents. This is particularly useful in e-commerce datasets where items have variations (e.g., different colors of the same product). This guide details how to configure and use the distinct attribute, both as an index setting and at search time, with verbose examples and tips. All provided data is preserved, formatted in Obsidian-friendly Markdown with emojis for clarity. 🛠️ Let’s dive in! 🏊



## 📌 Distinct Attribute Overview

The **distinct attribute** is a user-designated field that ensures search results contain only one document per unique value of that field. This is ideal for reducing redundancy in results, such as displaying only one variation of a product in an e-commerce search.

**Key Points**:
- **Purpose**: Prevents Meilisearch from returning multiple similar documents (e.g., different colors of the same jacket).
- **Configuration**: Set via the `distinctAttribute` index setting or the `distinct` search parameter.
- **Uniqueness**: Only one document per distinct attribute value is returned, selected based on ranking rules or internal ID if rankings are equal.
- **Use Case**: Common in e-commerce to avoid cluttered results with item variations.

**Example** 🎯: In a jackets index, setting `product_id` as the distinct attribute ensures only one jacket per `product_id` is returned, regardless of color variations.

**Tip** 💡: Use distinct attributes to streamline search results and improve user experience in datasets with many similar items.

**Warning** ⚠️: Updating `distinctAttribute` triggers re-indexing, which can be resource-intensive. Configure settings before adding documents to minimize RAM usage.

## 🌟 Setting a Distinct Attribute During Configuration

The `distinctAttribute` index setting applies a default distinct attribute to all searches and facet retrievals for an index. Only one `distinctAttribute` can be set per index.

**Behavior**:
- Ensures unique values in the distinct attribute field among returned documents.
- When multiple documents share the same distinct attribute value, Meilisearch returns the highest-ranked document based on ranking rules. If rankings are equal, the document with the lowest `internal_id` is chosen.

**Example** 🎯: For an e-commerce jackets index:
```json
[
  {
    "id": 1,
    "description": "Leather jacket",
    "brand": "Lee jeans",
    "color": "brown",
    "product_id": "123456"
  },
  {
    "id": 2,
    "description": "Leather jacket",
    "brand": "Lee jeans",
    "color": "black",
    "product_id": "123456"
  },
  {
    "id": 3,
    "description": "Leather jacket",
    "brand": "Lee jeans",
    "color": "blue",
    "product_id": "123456"
  }
]
```

Set `product_id` as the distinct attribute:
```go
package main

import (
    "fmt"
    "github.com/meilisearch/meilisearch-go"
)

func main() {
    client := meilisearch.NewClient(meilisearch.Config{
        Host:   "http://localhost:7700",
        APIKey: "masterKey",
    })
    task, err := client.Index("jackets").UpdateDistinctAttribute("product_id")
    if err != nil {
        fmt.Println("Error:", err)
        return
    }
    fmt.Printf("Task enqueued: %+v\n", task)
}
```

**Expected Response** (202 Accepted):
```json
{
  "taskUid": 1,
  "indexUid": "jackets",
  "status": "enqueued",
  "type": "settingsUpdate",
  "enqueuedAt": "2025-07-28T09:26:00.000000Z"
}
```

**Search Query**:
```go
resp, err := client.Index("jackets").Search("lee leather jacket", &meilisearch.SearchRequest{})
```

**Expected Output**:
```json
{
  "hits": [
    {
      "id": 1,
      "description": "Leather jacket",
      "brand": "Lee jeans",
      "color": "brown",
      "product_id": "123456"
    }
  ],
  "offset": 0,
  "limit": 20,
  "estimatedTotalHits": 1,
  "processingTimeMs": 0,
  "query": "lee leather jacket"
}
```

**Explanation**:
- Only one document with `product_id: "123456"` is returned, despite three matching documents.
- The document with `id: 1` is selected based on ranking rules or lowest `internal_id`.

**Tip** 💡: Use `distinctAttribute` for fields like `product_id` or `sku` in e-commerce to avoid duplicate product listings.

**Warning** ⚠️: Setting multiple fields as `distinctAttribute` causes an error. Choose one field carefully.

## 🌟 Setting a Distinct Attribute at Search Time

The `distinct` search parameter allows you to apply a distinct attribute for a specific query, overriding the `distinctAttribute` index setting. The attribute must be in the `filterableAttributes` list.

**Steps**:
1. Add the attribute to `filterableAttributes`.
2. Use the `distinct` parameter in the search query.

**Example** 🎯: Configure `filterableAttributes` and search with `distinct`:
```go
package main

import (
    "fmt"
    "github.com/meilisearch/meilisearch-go"
)

func main() {
    client := meilisearch.NewClient(meilisearch.Config{
        Host:   "http://localhost:7700",
        APIKey: "masterKey",
    })
    // Step 1: Update filterableAttributes
    filterableAttributes := []interface{}{
        "product_id",
        "sku",
        "url",
    }
    task, err := client.Index("products").UpdateFilterableAttributes(&filterableAttributes)
    if err != nil {
        fmt.Println("Error:", err)
        return
    }
    fmt.Printf("Task enqueued: %+v\n", task)

    // Step 2: Search with distinct
    resp, err := client.Index("products").Search("white shirt", &meilisearch.SearchRequest{
        Distinct: "sku",
    })
    if err != nil {
        fmt.Println("Error:", err)
        return
    }
    for _, hit := range resp.Hits {
        fmt.Printf("Hit: %+v\n", hit)
    }
}
```

**Tip** 💡: Use the `distinct` parameter for flexible searches where different queries need different uniqueness criteria (e.g., `sku` vs. `product_id`).

**Warning** ⚠️: Ensure the `distinct` attribute is in `filterableAttributes` to avoid query errors.

## 📚 API Operations for Distinct Attribute

### 🎯 Get Distinct Attribute

**Endpoint**: `GET /indexes/{index_uid}/settings/distinct-attribute`

**Path Parameters**:
- `index_uid` (String, required): UID of the index.

**Example** 🎯:
```go
package main

import (
    "fmt"
    "github.com/meilisearch/meilisearch-go"
)

func main() {
    client := meilisearch.NewClient(meilisearch.Config{
        Host:   "http://localhost:7700",
        APIKey: "masterKey",
    })
    attribute, err := client.Index("shoes").GetDistinctAttribute()
    if err != nil {
        fmt.Println("Error:", err)
        return
    }
    fmt.Printf("Distinct Attribute: %s\n", attribute)
}
```

**Expected Response** (200 OK):
```json
"skuid"
```

### 🎯 Update Distinct Attribute

**Endpoint**: `PUT /indexes/{index_uid}/settings/distinct-attribute`

**Path Parameters**:
- `index_uid` (String, required): UID of the index.

**Body**: A string representing an attribute (e.g., `"product_id"`). Supports dot notation for nested fields (e.g., `"product.skuid"`).

**Example** 🎯:
```go
package main

import (
    "fmt"
    "github.com/meilisearch/meilisearch-go"
)

func main() {
    client := meilisearch.NewClient(meilisearch.Config{
        Host:   "http://localhost:7700",
        APIKey: "masterKey",
    })
    task, err := client.Index("shoes").UpdateDistinctAttribute("skuid")
    if err != nil {
        fmt.Println("Error:", err)
        return
    }
    fmt.Printf("Task enqueued: %+v\n", task)
}
```

**Expected Response** (202 Accepted):
```json
{
  "taskUid": 1,
  "indexUid": "shoes",
  "status": "enqueued",
  "type": "settingsUpdate",
  "enqueuedAt": "2025-07-28T09:26:00.000000Z"
}
```

**Note**: If the attribute doesn’t exist, no error is thrown, but the setting has no effect.

### 🎯 Reset Distinct Attribute

**Endpoint**: `DELETE /indexes/{index_uid}/settings/distinct-attribute`

**Path Parameters**:
- `index_uid` (String, required): UID of the index.

**Example** 🎯:
```go
package main

import (
    "fmt"
    "github.com/meilisearch/meilisearch-go"
)

func main() {
    client := meilisearch.NewClient(meilisearch.Config{
        Host:   "http://localhost:7700",
        APIKey: "masterKey",
    })
    task, err := client.Index("shoes").ResetDistinctAttribute()
    if err != nil {
        fmt.Println("Error:", err)
        return
    }
    fmt.Printf("Task enqueued: %+v\n", task)
}
```

**Expected Response** (202 Accepted):
```json
{
  "taskUid": 1,
  "indexUid": "shoes",
  "status": "enqueued",
  "type": "settingsUpdate",
  "enqueuedAt": "2025-07-28T09:26:00.000000Z"
}
```

**Tip** 💡: Reset the distinct attribute during testing or when reconfiguring an index to remove uniqueness constraints.

## ✅ Summary

- **Distinct Attribute**: Ensures only one document per unique value is returned, ideal for e-commerce datasets with item variations.
- **Configuration**: Set via `distinctAttribute` (index-wide) or `distinct` (query-specific, requires `filterableAttributes`).
- **Behavior**: Returns the highest-ranked document for each distinct value, using `internal_id` as a tiebreaker.
- **API Operations**: Get, update, or reset the distinct attribute using dedicated endpoints.

**Additional Example** 🎯: For a shoe index, set `distinctAttribute: "style_id"` to show only one shoe style per search, and use `distinct: "color"` at query time for specific searches requiring color uniqueness.

**Warning** ⚠️: Re-indexing triggered by updating `distinctAttribute` can be resource-intensive. Plan updates during low-traffic periods or before indexing documents.



# 🚦 Meilisearch Displayed and Searchable Attributes

**Displayed** and **searchable attributes** in Meilisearch define which fields are returned in search results and which are used to match query terms, respectively. Properly configuring these settings can enhance application performance and search relevancy. This guide details how to manage `displayedAttributes` and `searchableAttributes`, including their default behaviors, manual configuration, and customization at search time. All provided data is preserved, formatted in Obsidian-friendly Markdown with emojis for clarity, and enriched with verbose examples and tips. 🛠️ Let’s dive in! 🏊



## 📌 Overview of Displayed and Searchable Attributes

Meilisearch maintains two key lists for each index:
- **displayedAttributes**: Determines which fields are included in the documents returned by a search query.
- **searchableAttributes**: Specifies which fields are searched for query term matches and their relevancy weight.

**Default Behavior**:
- All fields in a document are automatically added to both `displayedAttributes` and `searchableAttributes` based on their order in the first indexed document.
- New fields in subsequent documents are appended to both lists.
- This is indicated by `["*"]` for both settings.

**Key Points**:
- **Displayed Fields**: Only fields in `displayedAttributes` appear in search results.
- **Searchable Fields**: Only fields in `searchableAttributes` are checked for query matches and contribute to relevancy.
- **Storage**: All fields are stored in the database, regardless of their displayed or searchable status, and can be added to either list later.

**Example** 🎯: In a movie database, you might limit `displayedAttributes` to `title`, `overview`, `genres`, and `release_date` to reduce response size, and set `searchableAttributes` to `title` and `overview` to focus searches on relevant fields.

**Tip** 💡: Configure `displayedAttributes` to exclude unnecessary fields (e.g., internal IDs) to optimize response size and improve performance.

**Warning** ⚠️: A known bug causes manual updates to `searchableAttributes` to alter the displayed order of fields in JSON responses. This will be fixed in a future Meilisearch release.

## 🌟 Displayed Attributes

**Displayed attributes** control which fields appear in the documents returned by a search query. By default, all fields are displayed, but you can customize this to exclude fields irrelevant to the user experience (e.g., internal metadata).

**Behavior**:
- Fields not in `displayedAttributes` are excluded from search results but remain stored in the database.
- Use the **PUT /indexes/{index_uid}/settings/displayed-attributes** endpoint to update.

**Example** 🎯: Configure a `movies` index to display only `title`, `overview`, `genres`, and `release_date`:
```go
package main

import (
    "fmt"
    "github.com/meilisearch/meilisearch-go"
)

func main() {
    client := meilisearch.NewClient(meilisearch.Config{
        Host:   "http://localhost:7700",
        APIKey: "masterKey",
    })
    displayedAttributes := []string{
        "title",
        "overview",
        "genres",
        "release_date",
    }
    task, err := client.Index("movies").UpdateDisplayedAttributes(&displayedAttributes)
    if err != nil {
        fmt.Println("Error:", err)
        return
    }
    fmt.Printf("Task enqueued: %+v\n", task)
}
```

**Expected Response** (202 Accepted):
```json
{
  "taskUid": 1,
  "indexUid": "movies",
  "status": "enqueued",
  "type": "settingsUpdate",
  "enqueuedAt": "2025-07-28T09:28:00.000000Z"
}
```

**Search Query**:
```go
resp, err := client.Index("movies").Search("matrix", &meilisearch.SearchRequest{})
```

**Expected Output**:
```json
{
  "hits": [
    {
      "title": "The Matrix",
      "overview": "A hacker discovers…",
      "genres": ["sci-fi", "action"],
      "release_date": "1999"
    }
  ],
  "offset": 0,
  "limit": 20,
  "estimatedTotalHits": 1,
  "processingTimeMs": 0,
  "query": "matrix"
}
```

**Explanation**:
- Fields like `id` or other metadata are excluded from the response, reducing payload size.

**Tip** 💡: Exclude fields like `internal_id` or `url` from `displayedAttributes` to streamline responses, especially for large datasets.

**Warning** ⚠️: Ensure critical fields for user display are included to avoid incomplete search results.

## 🌟 Searchable Attributes

**Searchable attributes** determine which fields Meilisearch searches for query term matches and their impact on relevancy. Fields not in `searchableAttributes` are ignored during search but remain stored and can be made searchable later.

**Dual Purpose**:
1. **Designates Searchable Fields**: Specifies which fields are checked for query matches.
2. **Dictates Relevancy Order**: Fields earlier in the list contribute more to a document’s `_rankingScore` under the `attribute` ranking rule.

**Modes**:
- **Automatic (Default)**: All fields are searchable, ordered by their appearance in the first indexed document (`["*"]`). New fields are appended.
- **Manual**: Explicitly define searchable fields and their order, preventing automatic addition of new fields.

**Example** 🎯: For a movie index with fields `id`, `overview`, `genres`, `title`, `release_date`, make `id` and `release_date` non-searchable and prioritize `title`:
```go
package main

import (
    "fmt"
    "github.com/meilisearch/meilisearch-go"
)

func main() {
    client := meilisearch.NewClient(meilisearch.Config{
        Host:   "http://localhost:7700",
        APIKey: "masterKey",
    })
    searchableAttributes := []string{
        "title",
        "overview",
        "genres",
    }
    task, err := client.Index("movies").UpdateSearchableAttributes(&searchableAttributes)
    if err != nil {
        fmt.Println("Error:", err)
        return
    }
    fmt.Printf("Task enqueued: %+v\n", task)
}
```

**Expected Response** (202 Accepted):
```json
{
  "taskUid": 1,
  "indexUid": "movies",
  "status": "enqueued",
  "type": "settingsUpdate",
  "enqueuedAt": "2025-07-28T09:28:00.000000Z"
}
```

**Search Behavior**:
- A query for “1984” matches documents with “1984” in `title`, `overview`, or `genres`, but not `release_date` or `id`.
- Matches in `title` rank higher than those in `overview` or `genres` due to the order in `searchableAttributes`.

**Tip** 💡: Prioritize fields like `title` or `name` in `searchableAttributes` to align with user search intent.

**Warning** ⚠️: The bug affecting JSON field order after updating `searchableAttributes` may confuse users; verify output in critical applications.

### 🎯 Default Mode (Automatic)

- **Behavior**: All fields are searchable, ordered by their appearance in the first indexed document. New fields are appended.
- **Indicator**: `searchableAttributes: ["*"]`.
- **Verification**: Use **GET /indexes/{index_uid}/settings/searchable-attributes**.
- **Reset**: Set `searchableAttributes` to `[]` or use **DELETE /indexes/{index_uid}/settings/searchable-attributes**.

**Example** 🎯: If the first movie document is:
```json
{
  "id": 1,
  "title": "The Matrix",
  "overview": "A hacker discovers…",
  "genres": ["sci-fi"],
  "release_date": "1999"
}
```
- Default `searchableAttributes`: `["id", "title", "overview", "genres", "release_date"]`.

### 🎯 Manual Mode

- **Behavior**: Explicitly define searchable fields and their order. New fields are not automatically added unless settings are reset.
- **Update**: Use **PUT /indexes/{index_uid}/settings/searchable-attributes**.
- **Note**: Non-existent fields in the list don’t trigger errors but have no effect.

**Example** 🎯: Reorder and limit searchable fields:
```go
package main

import (
    "fmt"
    "github.com/meilisearch/meilisearch-go"
)

func main() {
    client := meilisearch.NewClient(meilisearch.Config{
        Host:   "http://localhost:7700",
        APIKey: "masterKey",
    })
    searchableAttributes := []string{
        "title",
        "overview",
        "genres",
    }
    task, err := client.Index("movies").UpdateSearchableAttributes(&searchableAttributes)
    if err != nil {
        fmt.Println("Error:", err)
        return
    }
    fmt.Printf("Task enqueued: %+v\n", task)
}
```

**Expected Response** (202 Accepted):
```json
{
  "taskUid": 1,
  "indexUid": "movies",
  "status": "enqueued",
  "type": "settingsUpdate",
  "enqueuedAt": "2025-07-28T09:28:00.000000Z"
}
```

### 🎯 Nested Fields

- **Behavior**: Use dot notation (e.g., `release_date.year`) to specify nested fields in `searchableAttributes` or `displayedAttributes`.
- **Impact**: Nested fields can have different relevancy weights or display settings than their parent.

**Example** 🎯: Prioritize `review.critic` over `review.user` in `searchableAttributes`:
```json
[
  "title",
  "review.critic",
  "overview",
  "review.user"
]
```

## 🌟 Customizing Attributes at Search Time

The `attributesToSearchOn` parameter restricts a specific query to a subset of `searchableAttributes`, overriding the default behavior.

**Parameter**:
- **Name**: `attributesToSearchOn`
- **Values**: Array of attribute names or `["*"]`/`null` (search all `searchableAttributes`)
- **Default**: `["*"]`

**Behavior**:
- Attributes must be in `searchableAttributes`.
- Order in `attributesToSearchOn` does not affect relevancy.

**Example** 🎯: Search only in `overview`:
```go
package main

import (
    "fmt"
    "github.com/meilisearch/meilisearch-go"
)

func main() {
    client := meilisearch.NewClient(meilisearch.Config{
        Host:   "http://localhost:7700",
        APIKey: "masterKey",
    })
    resp, err := client.Index("movies").Search("adventure", &meilisearch.SearchRequest{
        AttributesToSearchOn: []string{"overview"},
    })
    if err != nil {
        fmt.Println("Error:", err)
        return
    }
    for _, hit := range resp.Hits {
        fmt.Printf("Hit: %+v\n", hit)
    }
}
```

**Expected Behavior**:
- Only documents with “adventure” in `overview` are returned, even if `title` or `genres` are searchable.

**Tip** 💡: Use `attributesToSearchOn` for targeted searches, like focusing on product descriptions in e-commerce.

**Warning** ⚠️: Ensure attributes in `attributesToSearchOn` are in `searchableAttributes` to avoid errors.

## 📚 Data Storage

- **Behavior**: All fields are stored in the database, regardless of their status in `displayedAttributes` or `searchableAttributes`.
- **Implication**: Non-displayed or non-searchable fields can be re-added to either list at any time without data loss.

**Tip** 💡: Store internal fields (e.g., `sales_data`) as non-searchable and non-displayed to keep them accessible for future use without affecting search performance.

## 🌟 API Operations for Searchable Attributes

### 🎯 Update Searchable Attributes

**Endpoint**: `PUT /indexes/{index_uid}/settings/searchable-attributes`

**Path Parameters**:
- `index_uid` (String, required): UID of the index.

**Body**: An array of strings, ordered by relevancy importance. Supports dot notation for nested fields (e.g., `"release_date.year"`).

**Example** 🎯:
```go
package main

import (
    "fmt"
    "github.com/meilisearch/meilisearch-go"
)

func main() {
    client := meilisearch.NewClient(meilisearch.Config{
        Host:   "http://localhost:7700",
        APIKey: "masterKey",
    })
    searchableAttributes := []string{
        "title",
        "overview",
        "genres",
    }
    task, err := client.Index("movies").UpdateSearchableAttributes(&searchableAttributes)
    if err != nil {
        fmt.Println("Error:", err)
        return
    }
    fmt.Printf("Task enqueued: %+v\n", task)
}
```

**Expected Response** (202 Accepted):
```json
{
  "taskUid": 1,
  "indexUid": "movies",
  "status": "enqueued",
  "type": "settingsUpdate",
  "enqueuedAt": "2025-07-28T09:28:00.000000Z"
}
```

**Note**: Non-existent fields in the list don’t trigger errors but have no effect.

### 🎯 Reset Searchable Attributes

**Endpoint**: `DELETE /indexes/{index_uid}/settings/searchable-attributes`

**Path Parameters**:
- `index_uid` (String, required): UID of the index.

**Example** 🎯:
```go
package main

import (
    "fmt"
    "github.com/meilisearch/meilisearch-go"
)

func main() {
    client := meilisearch.NewClient(meilisearch.Config{
        Host:   "http://localhost:7700",
        APIKey: "masterKey",
    })
    task, err := client.Index("movies").ResetSearchableAttributes()
    if err != nil {
        fmt.Println("Error:", err)
        return
    }
    fmt.Printf("Task enqueued: %+v\n", task)
}
```

**Expected Response** (202 Accepted):
```json
{
  "taskUid": 1,
  "indexUid": "movies",
  "status": "enqueued",
  "type": "settingsUpdate",
  "enqueuedAt": "2025-07-28T09:28:00.000000Z"
}
```

**Tip** 💡: Reset `searchableAttributes` to `["*"]` during testing or to revert to automatic mode.

## ✅ Summary

- **Displayed Attributes**: Control which fields appear in search results, optimizing response size.
- **Searchable Attributes**: Define which fields are searched and their relevancy weight, with earlier fields having more impact.
- **Modes**: Automatic (`["*"]`) adds all fields; manual mode allows explicit control.
- **Storage**: All fields are stored, enabling flexibility to adjust settings later.
- **Search-Time Customization**: Use `attributesToSearchOn` for query-specific searches.

**Additional Example** 🎯: For a book index, set `displayedAttributes: ["title", "author", "summary"]` and `searchableAttributes: ["title", "author"]` to focus searches on key fields while displaying a concise summary, and use `attributesToSearchOn: ["author"]` for author-specific queries.

**Warning** ⚠️: The JSON field order bug in `searchableAttributes` updates may affect front-end display; verify outputs until fixed.

# 🚦 Meilisearch Synonyms

Synonyms in Meilisearch allow you to define sets of query terms that are considered equivalent during search, improving result relevancy by matching related terms. This guide explains how to configure synonyms, including one-way and mutual associations, multi-word synonyms, and their impact on search results. All provided data is preserved, formatted in Obsidian-friendly Markdown with emojis for clarity, and enriched with verbose examples and tips. 🛠️ Let’s dive in! 🏊



## 📌 Synonyms Overview

Synonyms enhance search relevancy by treating equivalent terms as interchangeable. For example, setting "great" and "fantastic" as synonyms ensures a search for one term also matches documents containing the other. Synonyms are normalized (lowercased and de-unicoded) during indexing, making searches case- and accent-insensitive.

**Key Points**:
- **Purpose**: Improves relevancy by matching related terms (e.g., "Résumé" and "CV").
- **Types**: One-way (e.g., `phone` → `iphone`) and mutual (e.g., `shoe` ↔ `boot`).
- **Normalization**: Synonyms are case-insensitive and ignore accents (e.g., "Résumé" matches "resume").
- **Relevancy**: Exact query terms are prioritized over synonyms due to the `exactness` ranking rule.
- **Limits**: Up to 50 synonyms per term, with a total of 100 words across all synonyms for a term.

**Example** 🎯: Setting "great" and "fantastic" as synonyms increases search results for both terms by matching documents containing either word.

**Tip** 💡: Use synonyms to align with user intent, such as equating brand names or common misspellings in your dataset.

**Warning** ⚠️: Overusing synonyms or adding too many can dilute relevancy or exceed Meilisearch’s limits, silently ignoring excess synonyms.

## 🌟 Configuring Synonyms

Synonyms are configured using the **PUT /indexes/{index_uid}/settings/synonyms** endpoint. The body is a JSON object mapping each term to an array of its synonyms.

### 🎯 Mutual Association

Mutual synonyms treat all listed terms as equivalent in both directions, ensuring searches for any term match documents containing any of the others.

**Example** 🎯: Set mutual synonyms for "shoe", "boot", "slipper", and "sneakers":
```go
package main

import (
    "fmt"
    "github.com/meilisearch/meilisearch-go"
)

func main() {
    client := meilisearch.NewClient(meilisearch.Config{
        Host:   "http://localhost:7700",
        APIKey: "masterKey",
    })
    synonyms := map[string][]string{
        "shoe":     []string{"boot", "slipper", "sneakers"},
        "boot":     []string{"shoe", "slipper", "sneakers"},
        "slipper":  []string{"shoe", "boot", "sneakers"},
        "sneakers": []string{"shoe", "boot", "slipper"},
    }
    task, err := client.Index("products").UpdateSynonyms(&synonyms)
    if err != nil {
        fmt.Println("Error:", err)
        return
    }
    fmt.Printf("Task enqueued: %+v\n", task)
}
```

**Expected Response** (202 Accepted):
```json
{
  "taskUid": 1,
  "indexUid": "products",
  "status": "enqueued",
  "type": "settingsUpdate",
  "enqueuedAt": "2025-07-28T09:30:00.000000Z"
}
```

**Search Behavior**:
- Query "shoe" matches documents with "boot", "slipper", or "sneakers".
- Query "boot" matches documents with "shoe", "slipper", or "sneakers".

**Tip** 💡: Use mutual synonyms for terms with equivalent meaning, like product categories (e.g., "shirt" ↔ "top").

### 🎯 One-Way Association

One-way synonyms map a term to another without reciprocation, useful when one term should match another but not vice versa.

**Example** 🎯: Map "phone" to "iphone":
```go
package main

import (
    "fmt"
    "github.com/meilisearch/meilisearch-go"
)

func main() {
    client := meilisearch.NewClient(meilisearch.Config{
        Host:   "http://localhost:7700",
        APIKey: "masterKey",
    })
    synonyms := map[string][]string{
        "phone": []string{"iphone"},
    }
    task, err := client.Index("products").UpdateSynonyms(&synonyms)
    if err != nil {
        fmt.Println("Error:", err)
        return
    }
    fmt.Printf("Task enqueued: %+v\n", task)
}
```

**Expected Response** (202 Accepted):
```json
{
  "taskUid": 1,
  "indexUid": "products",
  "status": "enqueued",
  "type": "settingsUpdate",
  "enqueuedAt": "2025-07-28T09:30:00.000000Z"
}
```

**Search Behavior**:
- Query "phone" matches documents with "iphone".
- Query "iphone" ranks documents with "phone" lower due to the `typo` rule, as "phone" is not a synonym of "iphone".

**Tip** 💡: Use one-way synonyms for broad-to-specific mappings, like "phone" → "iphone" or "car" → "sedan".

**Warning** ⚠️: One-way synonyms may reduce recall for the non-synonymized term (e.g., "iphone"), so test thoroughly.

### 🎯 Multi-Word Synonyms

Multi-word synonyms are treated as phrases, allowing a single term to match a phrase or vice versa.

**Example** 🎯: Set "San Francisco" and "SF" as mutual synonyms:
```go
package main

import (
    "fmt"
    "github.com/meilisearch/meilisearch-go"
)

func main() {
    client := meilisearch.NewClient(meilisearch.Config{
        Host:   "http://localhost:7700",
        APIKey: "masterKey",
    })
    synonyms := map[string][]string{
        "san francisco": []string{"sf"},
        "sf":            []string{"san francisco"},
    }
    task, err := client.Index("locations").UpdateSynonyms(&synonyms)
    if err != nil {
        fmt.Println("Error:", err)
        return
    }
    fmt.Printf("Task enqueued: %+v\n", task)
}
```

**Expected Response** (202 Accepted):
```json
{
  "taskUid": 1,
  "indexUid": "locations",
  "status": "enqueued",
  "type": "settingsUpdate",
  "enqueuedAt": "2025-07-28T09:30:00.000000Z"
}
```

**Search Behavior**:
- Query "SF" matches documents with "San Francisco".
- Query "San Francisco" matches documents with "SF".
- Exact matches (e.g., "SF" for "SF") rank higher due to the `exactness` rule.

**Tip** 💡: Use multi-word synonyms for location names or compound terms to improve search flexibility.

**Warning** ⚠️: Multi-word synonyms may rank lower than exact matches, so prioritize key phrases in `searchableAttributes` if needed.

### 🎯 Normalization

Synonyms are **lowercased** and **de-unicoded** during indexing, ensuring case- and accent-insensitive matching.

**Example** 🎯: Set "Résumé" and "CV" as synonyms:
```json
{
  "Résumé": ["CV"],
  "CV": ["Résumé"]
}
```

**Search Behavior**:
- Query "cv" matches "CV", "Résumé", "resume", or "resumé".
- Query "Résumé" matches "CV" or any variation of "resume".

**Tip** 💡: Leverage normalization to handle user input variations, especially in multilingual datasets.

## 🌟 Relevancy and Ranking

The `exactness` ranking rule prioritizes exact query matches over synonyms, ensuring precise searches rank higher.

**Example** 🎯: With synonyms `ghost` ↔ `spirit`:
```json
[
  {
    "id": 0,
    "title": "Ghouls 'n Ghosts"
  },
  {
    "id": 1,
    "title": "Phoenix Wright: Spirit of Justice"
  }
]
```

**Search Query**:
```go
resp, err := client.Index("games").Search("spirit", &meilisearch.SearchRequest{})
```

**Expected Behavior**:
- Document `id: 1` ("Spirit of Justice") ranks higher than `id: 0` ("Ghouls 'n Ghosts") due to exact match preference.

**Tip** 💡: Use `_rankingScoreDetails` to analyze how synonyms affect relevancy and adjust `rankingRules` if needed.

## 📚 Limits on Synonyms

- **Per Term**: Up to 50 synonyms per term. Excess synonyms are silently ignored.
- **Word Count**: Total words across all synonyms for a term cannot exceed 100. Excess words are ignored.

**Example** 🎯: If 51 synonyms are set for "book", only the first 50 are used. If synonyms for "computer" include 40 phrases totaling 101 words, the last phrase is ignored.

**Warning** ⚠️: Monitor synonym counts to avoid silent truncation, which can lead to unexpected search behavior.

## 🌟 API Operations for Synonyms

### 🎯 Update Synonyms

**Endpoint**: `PUT /indexes/{index_uid}/settings/synonyms`

**Path Parameters**:
- `index_uid` (String, required): UID of the index.

**Body**: A JSON object mapping terms to arrays of synonyms.

**Example** 🎯: Set synonyms for "wolverine", "logan", and "wow":
```go
package main

import (
    "fmt"
    "github.com/meilisearch/meilisearch-go"
)

func main() {
    client := meilisearch.NewClient(meilisearch.Config{
        Host:   "http://localhost:7700",
        APIKey: "masterKey",
    })
    synonyms := map[string][]string{
        "wolverine": []string{"xmen", "logan"},
        "logan":     []string{"wolverine", "xmen"},
        "wow":       []string{"world of warcraft"},
    }
    task, err := client.Index("movies").UpdateSynonyms(&synonyms)
    if err != nil {
        fmt.Println("Error:", err)
        return
    }
    fmt.Printf("Task enqueued: %+v\n", task)
}
```

**Expected Response** (202 Accepted):
```json
{
  "taskUid": 1,
  "indexUid": "movies",
  "status": "enqueued",
  "type": "settingsUpdate",
  "enqueuedAt": "2025-07-28T09:30:00.000000Z"
}
```

### 🎯 Reset Synonyms

**Endpoint**: `DELETE /indexes/{index_uid}/settings/synonyms`

**Path Parameters**:
- `index_uid` (String, required): UID of the index.

**Example** 🎯:
```go
package main

import (
    "fmt"
    "github.com/meilisearch/meilisearch-go"
)

func main() {
    client := meilisearch.NewClient(meilisearch.Config{
        Host:   "http://localhost:7700",
        APIKey: "masterKey",
    })
    task, err := client.Index("movies").ResetSynonyms()
    if err != nil {
        fmt.Println("Error:", err)
        return
    }
    fmt.Printf("Task enqueued: %+v\n", task)
}
```

**Expected Response** (202 Accepted):
```json
{
  "taskUid": 1,
  "indexUid": "movies",
  "status": "enqueued",
  "type": "settingsUpdate",
  "enqueuedAt": "2025-07-28T09:30:00.000000Z"
}
```

**Tip** 💡: Reset synonyms during testing or to clear outdated configurations.

## ✅ Summary

- **Synonyms**: Define equivalent terms to enhance search relevancy.
- **Types**: Mutual (bidirectional), one-way (unidirectional), and multi-word (phrases).
- **Normalization**: Case- and accent-insensitive matching.
- **Relevancy**: Exact matches rank higher than synonyms due to the `exactness` rule.
- **Limits**: 50 synonyms per term, 100 total words across synonyms.
- **API Operations**: Update or reset synonyms using dedicated endpoints.

**Additional Example** 🎯: For a book index, set mutual synonyms `["book", "novel", "tome"]` and one-way synonym `textbook → book` to match broad searches while preserving precision for specific terms.

**Warning** ⚠️: Exceeding synonym limits can lead to silent truncation, so validate your synonym list to ensure all terms are applied.

